Attention si on veux vraiment faire propre il faudrait que toutes les fonctions de la libft
qu'on utilise qui contiennent un malloc soit protegees

VAR = multiple words -------------------------
prototype : je peux t'envoyer shell ou command_array, ce que tu veux 
split_multiple_words_into_token

iterer sur chaque token, si le token commence par ' ou ", skipper, en revanche quand
token simple/sans quotes au debut, iterer le long et si plusieurs "words", alors "casser"
ce token en autant de tokens que de mots (en skippant espaces), et les inserer dans la liste

bash-3.2$ export VAR="bonjour             espaces"
bash-3.2$ echo llaa$VAR*OO
llaabonjour espaces*OO
bash-3.2$ echo "llaa$VAR*OO"
llaabonjour             espaces*OO

EVALUATOR -------------------------------------
Voir man bash 3.6 REDIRECTIONS 
->Pour recuperer l'output dans le cas de plusieurs input redirection consecutif il faut
peut etre simplement aussi faire un dup2() ou cette fois on link stderr et sdout a un
file qu'on cree nous mm en mode O_CREAT O_TRUNC et dans lequel on reecrira par dessus

A failure to open or create a file causes the redirection to fail.

Redirections using file descriptors greater than 9 should be used with care, 
as they may conflict with file descriptors the shell uses internally.

If no command name results, redirections are performed, but do not affect the current 
shell environment. A redirection error causes the command to exit with a non-zero status.

----------------------------------------------
The txt.txt file is created so file creation comes firsthand but then 
it is empty and output only ends up in lol.txt
bash-3.2$ echo hahaha >txt.txt >lol.txt
bash-3.2$ cat txt.txt
bash-3.2$ cat lol.txt
hahaha
-----------------------------------------------

https://www.sarathlakshman.com/2012/09/24/implementation-overview-of-redirection-and-pipe-operators-in-shell
VERIFIER si les redirections sont bien traitees en amont des execve ou si on fait un truc moche
comme ca : char *argv[] = { "/bin/bash", "-c", "/usr/bin/cat <<EOF\ntest\nEOF", 0};

REGLE : Pour les redir on ECRASE l'output, pour les arg NORMAUX, on APPEND les output les uns
a la suite des autres
RAPPEL : Un output peut soit etre un resultat, soit un message d'erreur

0) The output of each command in the pipeline is connected via a pipe to the input of 
the next command. That is, each command reads the previous command’s output. 
This connection is performed before any redirections specified by the command.
->voir 3.2.3 de man bash
0) Check if there are redirections in the cmd, if yes then goes to 1 if no goes to 2
	In any case next steps happen in child process : 
1) Execute < ou <<, dans leur ordre d'apparition
	- Pour executer < ou << on redirige le standard input sur le fd du fichier pointé par < ou
	le fichier tampon qu'on a cree nous meme dans le cas de <<

			dup2(fd, 0);
			execlp("cat", ...);

	- Chaque < ou << va ecraser l'output du precedent
	- Si le moindre soucis intervient sur un des < << (ex : fichier n'existe pas)
	alors l'output est l'output de l'erreur du < << courant et ARRETE TOUT LE PROCESS :
	les prochaines etapes n'auront pas lieu
	- Une fois tous les < et << faits, si dans la cmd il y a le moindre arg/fichier donné 
	directement en argument normal alors l'output qui avait ete cree sera ecrasé par celui
	des args "normaux"
3) Execute les arg/fichiers "normaux" (pas rediriges), output de chacun de ces fichiers sont
	APPEND les uns a la suite des autres


cat file1 file2 			-->affiche file1 file2
cat file1 <file2			--> n'affiche que file1 mais s'arrete quand meme si file2 n'existe pas
cat <file1 <file2			--> affiche file2 car il est le dernier a apparaitre

pour grep qui lui a en plus un "pattern" a chercher dans ces differents fichier, l'ordre compte
le PREMIER token venant apres grep qui N'EST PAS UNE REDIRECTION sera considéré comme le pattern
pour TOUS LES FICHIERS RECHERCHES donc
grep <file1 token1 token2 token3	-->token1 est le pattern et par elimination token2 et 3
									seront consideres d'emblee comme des fichiers


-------------------
For << 
https://stackoverflow.com/questions/41082647/implement-redirection-in-c
better : https://www.oilshell.org/blog/2016/10/18.html
so basically if << then it's like < except we need to create a temp file ourselves
that we will write into from stdin until we find the pattern listed on the right of <<
(ex : EOF) and then only we can dup2() and exec()

bash-3.2$ grep <<EOF main
> lala
> main
> encoremain
> erpuimain
> hehe
> c'est drole
> EOF
main
encoremain
erpuimain


bash-3.2$ echo lala | $5
bash-3.2$ ls
Applications	Documents	Library		Music		bin
Desktop		Downloads	Movies		Pictures	goinfre
bash-3.2$ echo lala | $VARR
bash-3.2$ ls
Applications	Documents	Library		Music		bin
Desktop		Downloads	Movies		Pictures	goinfre

If no command name results, the variable assignments affect the current 
shell environment. Otherwise, the variables are added to the environment of 
the executed command and do not affect the current shell environment. 
(If any of the assignments attempts to assign a value to a readonly variable, 
an error occurs, and the command exits with a non-zero status.)


ECHO ----------------------------------------
si echo "" il faudra print un espace

bash-3.2$ export VAR="   sansespaces"
bash-3.2$ env | grep "VAR"
VAR=   sansespaces
bash-3.2$ echo $VAR
sansespaces

echo trim first spaces of a var


EXIT ----------------------------------------
prints an "exit" msg on stdERR when we do exit


PARSER ----- DRAFT -----------------
static void	set_flags(t_token **cmd_array)
{
	int			i;
	t_token		*cpy;
	
	initialize_flags_values(cmd_array);
	i = 0;
	while (cmd_array[i])
	{
		cpy = cmd_array[i];
		turn_on_flag(CMD, cpy);
		cpy = cpy->next;
		while (cpy)
		{
			if (is_redirection(cpy->word, 0))
			//{
				turn_on_flag(REDIR, cpy);
			//	if (after_redir(&cpy, cmd_array[i + 1]) == NOTHING_AFTER_REDIR)
			//		return (NOTHING_AFTER_REDIR);			
			//}
			else
				turn_on_flag(ARG, cpy);
			cpy = cpy->next;
		}
		i++;
	}
	return (1);
}