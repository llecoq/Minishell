Attention si on veux vraiment faire propre il faudrait que toutes les fonctions de la libft
qu'on utilise qui contiennent un malloc soit protegees

EVALUATOR -------------------------------------

Pipes run concurrently :
https://unix.stackexchange.com/questions/37508/in-what-order-do-piped-commands-run

Montre que les messages d'erreur sont asynchrones 
bash-3.2$ cat < bonjour.txt | echo haha
haha
bash: bonjour.txt: No such file or directory
bash-3.2$ cat < bonjour.txt | echo haha
bash: bonjour.txt: No such file or directory
haha

En tout premier creer les pipes des differentes commandes?

Voir man bash 3.6 REDIRECTIONS 
->Pour recuperer l'output dans le cas de plusieurs input redirection consecutif il faut
peut etre simplement aussi faire un dup2() ou cette fois on link stderr et sdout a un
file qu'on cree nous mm en mode O_CREAT O_TRUNC et dans lequel on reecrira par dessus

Redirections using file descriptors greater than 9 should be used with care, 
as they may conflict with file descriptors the shell uses internally.

If no command name results, redirections are performed, but do not affect the current 
shell environment. A redirection error causes the command to exit with a non-zero status.

----------------------------------------------
The txt.txt file is created so file creation comes firsthand but then 
it is empty and output only ends up in lol.txt
bash-3.2$ echo hahaha >txt.txt >lol.txt
bash-3.2$ cat txt.txt
bash-3.2$ cat lol.txt
hahaha
-----------------------------------------------

https://www.sarathlakshman.com/2012/09/24/implementation-overview-of-redirection-and-pipe-operators-in-shell
VERIFIER si les redirections sont bien traitees en amont des execve ou si on fait un truc moche
comme ca : char *argv[] = { "/bin/bash", "-c", "/usr/bin/cat <<EOF\ntest\nEOF", 0};

REGLE : Pour les redir on ECRASE l'output, pour les arg NORMAUX, on APPEND les output les uns
a la suite des autres
RAPPEL : Un output peut soit etre un resultat, soit un message d'erreur

0) The output of each command in the pipeline is connected via a pipe to the input of 
the next command. That is, each command reads the previous command’s output. 
This connection is performed before any redirections specified by the command.
->voir 3.2.3 de man bash
0) Check if there are redirections in the cmd, if yes then goes to 1 if no goes to 2
	In any case next steps happen in child process : 
1) Execute < ou <<, dans leur ordre d'apparition
	- Pour executer < ou << on redirige le standard input sur le fd du fichier pointé par < ou
	le fichier tampon qu'on a cree nous meme dans le cas de <<

			dup2(fd, 0);
			execlp("cat", ...);

	- Chaque < ou << va ecraser l'output du precedent
	- Si le moindre soucis intervient sur un des < << (ex : fichier n'existe pas)
	alors l'output est l'output de l'erreur du < << courant et ARRETE TOUT LE PROCESS :
	les prochaines etapes n'auront pas lieu
	- Une fois tous les < et << faits, si dans la cmd il y a le moindre arg/fichier donné 
	directement en argument normal alors l'output qui avait ete cree sera ecrasé par celui
	des args "normaux"
3) Execute les arg/fichiers "normaux" (pas rediriges), output de chacun de ces fichiers sont
	APPEND les uns a la suite des autres


cat file1 file2 			-->affiche file1 file2
cat file1 <file2			--> n'affiche que file1 mais s'arrete quand meme si file2 n'existe pas
cat <file1 <file2			--> affiche file2 car il est le dernier a apparaitre

pour grep qui lui a en plus un "pattern" a chercher dans ces differents fichier, l'ordre compte
le PREMIER token venant apres grep qui N'EST PAS UNE REDIRECTION sera considéré comme le pattern
pour TOUS LES FICHIERS RECHERCHES donc
grep <file1 token1 token2 token3	-->token1 est le pattern et par elimination token2 et 3
									seront consideres d'emblee comme des fichiers


----------------------------------------
bash$ cat < 1
0
bash$ cat < 1 | wc -l
1
bash$ cat < 1 | wc -l > 1
bash$ cat 1
0
Voir multiple open on same file dans drafts
si on fait open deux fois de suite sur meme fichier, on obtient deux fd
differents qui font reference au meme fichier et non pas le meme fd
mais ce n'est pas un soucis, on aura juste a avancer de gauche a droite normalement
et apres avoir fini d'utiliser un fd (=fini d'utiliser une redir) il faudra fermer le fd
-------------------
For << 
https://stackoverflow.com/questions/41082647/implement-redirection-in-c
better : https://www.oilshell.org/blog/2016/10/18.html
We create a buffer :
while (gnl(0, &&line))
{
	if line == stop	(token apres >>)
		dup2(); input devient notre buffer
		execve();
	else 
		add line to buffer/char**argv?
}
Or do we create a temp file -> but we cannot use a function to delete that file afterwards
Maybe instead of temp file we need to use a pipe

bash-3.2$ cat << lol lol haha
> hehe
> lol
lol
haha
et une fois de plus, l'output d'une redirection est overwritten par les outputs d'args simples

bash-3.2$ grep <<EOF main
> lala
> main
> encoremain
> erpuimain
> hehe
> c'est drole
> EOF
main
encoremain
erpuimain
Pour grep, l'argument juste apres s'il n'est pas une option est FORCEMENT le pattern


bash-3.2$ rm *
bash-3.2$ echo lala | $5
bash-3.2$ ls
bash-3.2$
Ici pas d'erreur pour $5 alors que ce n'est pas une commande qui existe
si cmd == '\0' alors pas de message d'erreur
Donc ici $5 devrait etre enleve de la liste donc cmd_array[1] devient NULL mais le pipe
a quand meme lieu

bash-3.2$ $5 lala
bash: lala: command not found
Visiblement quand un token est = '\0' alors on ne le cherche pas

bash-3.2$ export VAR=noexist
bash-3.2$ echo lala | $VAR
bash: noexist: command not found

If no command name results, the variable assignments affect the current 
shell environment. Otherwise, the variables are added to the environment of 
the executed command and do not affect the current shell environment. 
(If any of the assignments attempts to assign a value to a readonly variable, 
an error occurs, and the command exits with a non-zero status.)


ECHO ----------------------------------------
si echo "" il faudra print un espace, avec trim quotes c'est transforme en '\0'
donc si argv[i][0] == '\0' alors print ' ', comme le vrai echo qui quand il prend
un argv avec '\0' il imprime un espace -> voir draftminishell
	char *args[]={"echo", "lol", "", "mots", NULL};
	lol  mots

!!Echo ignore toutes les INPUT redirections

bash-3.2$ export VAR="   sansespaces"
bash-3.2$ env | grep "VAR"
VAR=   sansespaces
bash-3.2$ echo $VAR
sansespaces

echo trim first spaces of a var

bash-3.2$ echo elephant > lol
bash-3.2$ echo < lol

bash-3.2$ echo << EOF
> haha
> hehe
> EOF

bash-3.2$


EXIT ----------------------------------------
prints an "exit" msg on stdERR when we do exit