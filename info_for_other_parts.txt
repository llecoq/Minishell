Attention si on veux vraiment faire propre il faudrait que toutes les fonctions de la libft
qu'on utilise qui contiennent un malloc soit protegees

EVALUATOR -------------------------------------

Pipes run concurrently :
https://unix.stackexchange.com/questions/37508/in-what-order-do-piped-commands-run

Montre que les messages d'erreur sont asynchrones 
bash-3.2$ cat < bonjour.txt | echo haha
haha
bash: bonjour.txt: No such file or directory
bash-3.2$ cat < bonjour.txt | echo haha
bash: bonjour.txt: No such file or directory
haha

En tout premier creer les pipes des differentes commandes?

Voir man bash 3.6 REDIRECTIONS 
->Pour recuperer l'output dans le cas de plusieurs input redirection consecutif il faut
peut etre simplement aussi faire un dup2() ou cette fois on link stderr et sdout a un
file qu'on cree nous mm en mode O_CREAT O_TRUNC et dans lequel on reecrira par dessus

Redirections using file descriptors greater than 9 should be used with care, 
as they may conflict with file descriptors the shell uses internally.

If no command name results, redirections are performed, but do not affect the current 
shell environment. A redirection error causes the command to exit with a non-zero status.

----------------------------------------------
The txt.txt file is created so file creation comes firsthand but then 
it is empty and output only ends up in lol.txt
bash-3.2$ echo hahaha >txt.txt >lol.txt
bash-3.2$ cat txt.txt
bash-3.2$ cat lol.txt
hahaha
-----------------------------------------------

https://www.sarathlakshman.com/2012/09/24/implementation-overview-of-redirection-and-pipe-operators-in-shell
VERIFIER si les redirections sont bien traitees en amont des execve ou si on fait un truc moche
comme ca : char *argv[] = { "/bin/bash", "-c", "/usr/bin/cat <<EOF\ntest\nEOF", 0};

REGLE : Pour les redir on ECRASE l'output, pour les arg NORMAUX, on APPEND les output les uns
a la suite des autres
RAPPEL : Un output peut soit etre un resultat, soit un message d'erreur

0) The output of each command in the pipeline is connected via a pipe to the input of 
the next command. That is, each command reads the previous command’s output. 
This connection is performed before any redirections specified by the command.
->voir 3.2.3 de man bash
0) Check if there are redirections in the cmd, if yes then goes to 1 if no goes to 2
	In any case next steps happen in child process : 
1) Execute < ou <<, dans leur ordre d'apparition
	- Pour executer < ou << on redirige le standard input sur le fd du fichier pointé par < ou
	le fichier tampon qu'on a cree nous meme dans le cas de <<

			dup2(fd, 0);
			execlp("cat", ...);

	- Chaque < ou << va ecraser l'output du precedent
	- Si le moindre soucis intervient sur un des < << (ex : fichier n'existe pas)
	alors l'output est l'output de l'erreur du < << courant et ARRETE TOUT LE PROCESS :
	les prochaines etapes n'auront pas lieu
	- Une fois tous les < et << faits, si dans la cmd il y a le moindre arg/fichier donné 
	directement en argument normal alors l'output qui avait ete cree sera ecrasé par celui
	des args "normaux"
3) Execute les arg/fichiers "normaux" (pas rediriges), output de chacun de ces fichiers sont
	APPEND les uns a la suite des autres


cat file1 file2 			-->affiche file1 file2
cat file1 <file2			--> n'affiche que file1 mais s'arrete quand meme si file2 n'existe pas
cat <file1 <file2			--> affiche file2 car il est le dernier a apparaitre

pour grep qui lui a en plus un "pattern" a chercher dans ces differents fichier, l'ordre compte
le PREMIER token venant apres grep qui N'EST PAS UNE REDIRECTION sera considéré comme le pattern
pour TOUS LES FICHIERS RECHERCHES donc
grep <file1 token1 token2 token3	-->token1 est le pattern et par elimination token2 et 3
									seront consideres d'emblee comme des fichiers


----------------------------------------
bash$ cat < 1
0
bash$ cat < 1 | wc -l
1
bash$ cat < 1 | wc -l > 1
bash$ cat 1
0
Voir multiple open on same file dans drafts
si on fait open deux fois de suite sur meme fichier, on obtient deux fd
differents qui font reference au meme fichier et non pas le meme fd
mais ce n'est pas un soucis, on aura juste a avancer de gauche a droite normalement
et apres avoir fini d'utiliser un fd (=fini d'utiliser une redir) il faudra fermer le fd
-------------------
For << --> !! le fd n'est pas set
https://stackoverflow.com/questions/41082647/implement-redirection-in-c
better : https://www.oilshell.org/blog/2016/10/18.html
We create a buffer :
while (gnl(0, &&line))
{
	if line == stop	(token apres >>)
		dup2(); input devient notre buffer
		execve();
	else 
		add line to buffer/char**argv?
}
Or do we create a temp file -> but we cannot use a function to delete that file afterwards
Maybe instead of temp file we need to use a pipe

➜  ~ export VAR="deux mots"
➜  ~ cat << $VAR					!! ICI la var $VAR n'est pas expanded/traduite
heredoc> deux
heredoc> mots
heredoc> deux mots
heredoc> VAR
heredoc> $VAR
deux
mots
deux mots
VAR

bash-3.2$ cat << lol lol haha
> hehe
> lol
lol
haha
et une fois de plus, l'output d'une redirection est overwritten par les outputs d'args simples

bash-3.2$ grep <<EOF main
> lala
> main
> encoremain
> erpuimain
> hehe
> c'est drole
> EOF
main
encoremain
erpuimain
Pour grep, l'argument juste apres s'il n'est pas une option est FORCEMENT le pattern


bash-3.2$ rm *
bash-3.2$ echo lala | $5
bash-3.2$ ls
bash-3.2$
Ici pas d'erreur pour $5 alors que ce n'est pas une commande qui existe
si cmd == '\0' alors pas de message d'erreur
Donc ici $5 devrait etre enleve de la liste donc cmd_array[1] devient NULL mais le pipe
a quand meme lieu

bash-3.2$ $5 lala
bash: lala: command not found
Visiblement quand un token est = '\0' alors on ne le cherche pas

bash-3.2$ export VAR=noexist
bash-3.2$ echo lala | $VAR
bash: noexist: command not found

If no command name results, the variable assignments affect the current 
shell environment. Otherwise, the variables are added to the environment of 
the executed command and do not affect the current shell environment. 
(If any of the assignments attempts to assign a value to a readonly variable, 
an error occurs, and the command exits with a non-zero status.)


ECHO ----------------------------------------
si echo "" il faudra print un espace, avec trim quotes c'est transforme en '\0'
donc si argv[i][0] == '\0' alors print ' ', comme le vrai echo qui quand il prend
un argv avec '\0' il imprime un espace -> voir draftminishell
	char *args[]={"echo", "lol", "", "mots", NULL};
	lol  mots

!!Echo ignore toutes les INPUT redirections

bash-3.2$ export VAR="   sansespaces"
bash-3.2$ env | grep "VAR"
VAR=   sansespaces
bash-3.2$ echo $VAR
sansespaces

echo trim first spaces of a var

bash-3.2$ echo elephant > lol
bash-3.2$ echo < lol

bash-3.2$ echo << EOF
> haha
> hehe
> EOF

bash-3.2$


EXIT ----------------------------------------
prints an "exit" msg on stdERR when we do exit
$? should expand to the exit status of the most recently executed foreground
pipeline.

EXECUTOR -------------------------------------

heredoc (il doit s'ouvrir en tout premier quelque soit sa position dans l'input, c'est la seule redirection qui se cree avant)
creation des pipe()
creation des fork()
creation des redirections (renvoie d'erreur si le file en input n'existe pas)
recherche des cmds (renvoie d'erreur si cmd n'existe pas)
execution de tout le bordel, dup des fd et print la ou il faut
SUCCESS - OUTSTANDING PROJECT

Attention, si UNSET PATH
redir = 0644
ctrl + d dans un heredoc flush l'input mais ne quite pas minishell, donc les
autres commandes et redir se lancent quand meme apres
quand on fait une redirection, on ne close pas le fichier redirige (apres dup2)

utiliser waitpid pour retourner code erreur WEXITSTATUS
waitpid recupere la valeur de retour du fork child
WEXITSTATUS permet de traduire le code erreur en INT classique


Pour gagner du temps lors d'un fork, le noyau ne duplique que le mappage mémoire. 
Par exemple, si nous avons cent pages mappées pour le tableau, le noyau va 
dupliquer les entrées TLB (Translation Lookaside Buffer) et basculer tous les 
mappages en lecture seule. Si les deux processus effectuent uniquement des 
lectures, ils accèdent à de la mémoire partagée, mais quand un des processus 
essaye d'écrire, il déclenche un défaut de page (page fault), le gestionnaire 
d'interruptions (trap) du noyau copie la page et change sa permission en 
lecture-écriture, puis remet le pointeur d'instruction à sa valeur initiale 
pour que le programme puisse exécuter à nouveau l'opération d'écriture.

ATTENTION POUR SET_REDIRECTION :

bash-3.2$ pwd > teeest/oui
bash-3.2$ cd teeest/
bash-3.2$ cat oui
/Users/llecoq/test
bash-3.2$ pwd > test/oui
bash: test/oui: No such file or directory


variable d'environnement devrait etre gerer a l'exec ?
Car si bash: export VAR=ZOB | echo $VAR

creer buff pour printf, write doit s'executer d'un seul coup
rl_clear_history()

gerer script

attention stop value dup, mais apres arg quand meme dans cat
bash-3.2$ cat << stop oui
> lkajhdf
> sjkdhf
> stop oui
> stop
cat: oui: No such file or directory
bash-3.2$ cat << stop
> oui
> stop
oui

attention a revoir peutetre fonctionnement prompt avec ctrl + d par exemple
readline rajoute un \n alors que bash non

lorsque CRT+D dans heredoc, saute une ligne

$(NAME):	$(OBJS)
			$(MAKE) -C ./gnl
			$(MAKE) -C ./ft_printf
			cp gnl/libgnl.a $(NAME)
			cp ft_printf/libftprintf.a $(NAME)
			ar rcs $(NAME) $(OBJS)
			ranlib $(NAME)

PROBLEM AFFICHAGE QUAND CTRL+V

Makefile ne recompil pas si je change enum dans .h

echo $NONEXISTENTVAR leaks de taille 16 (2 * 8 (char *))



echo """hahah 'c nul $VAR' haha"""

==================================================================================================

/*	
	Donc deroulement du parsing :
	
NO		NB : le dernier token qui contient le pipe est inutile puisque chaque cmd_array est
NO		necessairement separé par un pipe --> PAS FAIT CAR BESOIN DU PIPE POUR nothing_after_redir
OK		0) Mettre les flags redir et arg seulement (car la premier var peut etre une cmd du type : 
OK		CMDNAME="echo     haha")
OK		1)toutes les var qui ne sont pas des redir sont expandues
OK		1bis)si elles font plusieurs mots il faut les splitter en x tokens (seulement les var, pas 
		les tokens simples) et les ajouter a la liste (ajout de maillon)
OK		2) Si le premier token/word n'a pas le flag REDIR on alors on set son flag a CMD sinon on laisse
		tel quel.
		Une cmd_array peut commencer par une redirection par contre si il commence par une var qui contient
		une redir alors il aura le flag ARG et on aura msg d'erreur bash: >>: command not found
		bash-3.2$ >> haha				<--fonctionne
		bash-3.2$ export REDIR=">>"		<--ne fonctionne pas
		bash-3.2$ $REDIR loool
		Donc on regarde bien juste le flag, ne pas faire is_redirection(first_token)
		3)avant l'execution de la commande les redirections sont crees de gauche a droite: 
OK			a) la premiere est cree : VAR expandues, si pas d'erreur d'expansion, le fichier est 
			cherché et si n'existe pas il est cree. Pour ca on utilise open() et selon si redir < ou >
			alors open(O_CREAT, O_TRUNC) et si redir << ou >> open(O_CREATE) comme ca le contenu sera bien
			overwritten quand il doit l'etre
OK			c) la deuxieme redir (de gauche a droite) est cree, 
				si erreur on arrete tout ici
				si pas d'erreur alors crea de redir suivante et ainsi de suite
OK			Si erreur au cours de l'ouverture/crea d'un des fichiers alors cette commande ne sera
			pas executee, effacer cette cmd de cmd_array?
OK		4) Trim quotes
OK		5) Check si la commande existe juste avant de la lancer mais APRES les redirections
		6)char **argv est cree
EVAL	7) la commande est executee SUR LA TOUTE DERNIERE REDIRECTION, les autres sont "ignorees", seuls
		les fichiers ont etes crees donc /!\ a la gestion des fd qu'il faudra bien close
		NON! pour << HEREDOC, toutes les redirections sont prises en compte mais heredoc ne cree pas de 
		fichier qui "reste", peut etre un fichier temporaire ou un buffer?
EVAL	8) on passe a la commande suivante
		
			bash-3.2$ echo < othertxt.txt > hehe
			bash-3.2$ ls
			hehe		hihi		othertxt.txt	txt.txt
			bash-3.2$ cat hehe
		FAUX : Montre que la commande est bien executee seulement sur la derniere redirection (mais les fichiers
		intermediaires sont bien crees) puisque c'est comme si on avait fait echo > hehe
		FAUX car echo ignore les input redir d'ou l'impression qu'il n'y a que la derniere redir qui est
		executee	

*/


//OK en dessous--------------------------------------------------------------

/*
Vendredi 16 Juillet avant de faire char **argv a 17h20

OK Ici pas d'erreur pour $5 alors que ce n'est pas une commande qui existe
si cmd == '\0' alors pas de message d'erreur
bash-3.2$ rm *
bash-3.2$ echo lala | $5
bash-3.2$ ls
bash-3.2$

OK Alors que si var non vide on a bien un msg d'erreur si cmd n'existe pas
bash-3.2$ export VAR=noexist
bash-3.2$ echo lala | $VAR
bash: noexist: command not found

OK Visiblement quand un token est = '\0' alors on ne le cherche pas
bash-3.2$ $5 lala
bash: lala: command not found

Donc des qu'un token qui n'est pas une redirection devient '\0' apres var
expansion on l'enleve de la liste AVANT de set le flag cmd ou autre
*/

/*
OK	Errors FROM DIFFERENT COMMANDS add to each other but if there are 2 errors WITHIN ONE CMD
	only the first one/error msg appears
	Even if there is an error on one command, the next cmd will be executed

		bash-3.2$ echo < $VARR | txt.txt
		bash: $VARR: ambiguous redirect
		bash: txt.txt: command not found

		bash-3.2$ echo haha > $5 | echo haha
		bash: $5: ambiguous redirect
		haha		
	
	Cas sans erreur : Trois fichiers sont crees et c'est le dernier qui contiendra "lalala",
	les autres sont vides
	
		bash-3.2$ rm *
		bash-3.2$ echo lalala > txt.txt > hihi > othertxt.txt
		bash-3.2$ ls
		hihi		othertxt.txt	txt.txt
	
OK	Cas avec erreur : Ici on voit que last.txt n'a pas ete cree car il vient apres 
	un ambiguous redirect. Montre que les redir ne sont expandues qu'au moment meme ou elles
	doivent etre executees/la redir doit etre cree -> car elles ne sont pas inclues comme des arg
	dans char **argv. 
		
		bash-3.2$ rm *
		bash-3.2$ echo lalala > txt.txt > $OTHERVAR > last.txt
		bash: $OTHERVAR: ambiguous redirect
		bash-3.2$ ls
		txt.txt
		bash-3.2$ cat txt.txt
		bash-3.2$
		

OK	bash-3.2$ cat hoho <txt.txt < $VAR
	bash: $VAR: ambiguous redirect
	-->ambiguous redirect stop meme cat hoho
	bash-3.2$ cat hoho <txt.txt
	blablbalba
	bash-3.2$ cat hoho
	blablbalba
	bash-3.2$ cat txt.txt
	elephant
	bash-3.2$ cat hoho <bonjour <$VAR
	bash: bonjour: No such file or directory
	Ici on voit qu'on n'arrive pas a <$VAR et sachant que les redirections sont faites AVANT les
	arguments normaux, on voit bien que la commande est stoppee au moment ou une erreur apparait
	
	bash-3.2$ cat file_that_no_exist <no_exist <$VAR
	bash: no_exist: No such file or directory
	Ici ca confirme ca : le fichier file_that_no_exist n'a pas ete testé, c'est au moment de creer
	la redirection (pipe dup) que no_exist est testé -> erreur -> arret du process

		bash-3.2$ rm *
		bash-3.2$ blabla hoho > txt.txt
		bash: blabla: command not found
		bash-3.2$ ls
		txt.txt
	montre que les fichiers de redir sont crees avant meme que l'existence de la cmd soit checkee
*/