Attention si on veux vraiment faire propre il faudrait que toutes les fonctions de la libft
qu'on utilise qui contiennent un malloc soit protegees

EVALUATOR -------------------------------------
Voir man bash 3.6 REDIRECTIONS 
->Pour recuperer l'output dans le cas de plusieurs input redirection consecutif il faut
peut etre simplement aussi faire un dup2() ou cette fois on link stderr et sdout a un
file qu'on cree nous mm en mode O_CREAT O_TRUNC et dans lequel on reecrira par dessus

A failure to open or create a file causes the redirection to fail.

Redirections using file descriptors greater than 9 should be used with care, as they may conflict with file descriptors the shell uses internally.



https://www.sarathlakshman.com/2012/09/24/implementation-overview-of-redirection-and-pipe-operators-in-shell
VERIFIER si les redirections sont bien traitees en amont des execve ou si on fait un truc moche
comme ca : char *argv[] = { "/bin/bash", "-c", "/usr/bin/cat <<EOF\ntest\nEOF", 0};

REGLE : Pour les redir on ECRASE l'output, pour les arg NORMAUX, on APPEND les output les uns
a la suite des autres
RAPPEL : Un output peut soit etre un resultat, soit un message d'erreur

0) The output of each command in the pipeline is connected via a pipe to the input of 
the next command. That is, each command reads the previous command’s output. 
This connection is performed before any redirections specified by the command.
->voir 3.2.3 de man bash
0) Check if there are redirections in the cmd, if yes then goes to 1 if no goes to 2
	In any case next steps happen in child process : 
1) Execute < ou <<, dans leur ordre d'apparition
	- Pour executer < ou << on redirige le standard input sur le fd du fichier pointé par < ou
	le fichier tampon qu'on a cree nous meme dans le cas de <<

			dup2(fd, 0);
			execlp("cat", ...);

	- Chaque < ou << va ecraser l'output du precedent
	- Si le moindre soucis intervient sur un des < << (ex : fichier n'existe pas)
	alors l'output est l'output de l'erreur du < << courant et ARRETE TOUT LE PROCESS :
	les prochaines etapes n'auront pas lieu
	- Une fois tous les < et << faits, si dans la cmd il y a le moindre arg/fichier donné 
	directement en argument normal alors l'output qui avait ete cree sera ecrasé par celui
	des args "normaux"
3) Execute les arg/fichiers "normaux" (pas rediriges), output de chacun de ces fichiers sont
	APPEND les uns a la suite des autres


cat file1 file2 			-->affiche file1 file2
cat file1 <file2			--> n'affiche que file1 mais s'arrete quand meme si file2 n'existe pas
cat <file1 <file2			--> affiche file2 car il est le dernier a apparaitre

pour grep qui lui a en plus un "pattern" a chercher dans ces differents fichier, l'ordre compte
le PREMIER token venant apres grep qui N'EST PAS UNE REDIRECTION sera considéré comme le pattern
pour TOUS LES FICHIERS RECHERCHES donc
grep <file1 token1 token2 token3	-->token1 est le pattern et par elimination token2 et 3
									seront consideres d'emblee comme des fichiers


-------------------
For << 
https://stackoverflow.com/questions/41082647/implement-redirection-in-c
better : https://www.oilshell.org/blog/2016/10/18.html
so basically if << then it's like < except we need to create a temp file ourselves
that we will write into from stdin until we find the pattern listed on the right of <<
(ex : EOF) and then only we can dup2() and exec()

bash-3.2$ grep <<EOF main
> lala
> main
> encoremain
> erpuimain
> hehe
> c'est drole
> EOF
main
encoremain
erpuimain

For < 


ECHO ----------------------------------------
si echo "" il faudra print un espace
